{"version":3,"file":"index.esm.js","sources":["../src/utils.ts","../src/FormDomain.ts","../src/FormContext.ts","../src/FieldContext.ts","../src/FormIf.ts"],"sourcesContent":["import { ValidationError } from 'yup';\n\nexport const isValidationError = (err: any): err is ValidationError => {\n  if (!err || typeof err !== 'object') {\n    return false;\n  }\n  return err.name === 'ValidationError';\n};\n","import { action, computed, observable, runInAction, toJS, IComputedValue, decorate } from 'mobx';\nimport React from 'react';\nimport { ReactChild } from 'react';\nimport { ObjectSchema } from 'yup';\nimport { isValidationError } from './utils';\n\ninterface FormStatus {\n  appearance?: 'info' | 'warning' | 'danger' | 'success';\n  message: ReactChild;\n  hideAfter?: number;\n}\n\ntype ValidationState = 'warning' | 'success' | 'error';\n\n// These field props are usually handled by methods and values on the field context.\ntype OmittedProps = 'validationState' | 'onChange' | 'onBlur' | 'name' | 'value' | 'defaultValue';\n\n/** Exclude common handled field props from an interface */\nexport type OmitFieldProps<T> = Pick<T, Exclude<keyof T, OmittedProps>>;\n\n/** Handler passed as the `onSubmit` prop */\nexport type SubmitHandler<T extends object> = (values: T) => Promise<FormStatus | undefined>;\n\nexport interface FormDomainProps<T extends object> {\n  initialValues: T;\n  validationSchema: ObjectSchema<T>;\n  onSubmit: SubmitHandler<T>;\n}\n\nexport interface FieldContextObj<T extends any> {\n  name: string;\n\n  handleFocus: () => void;\n  handleBlur: () => void;\n  handleCheckboxChange: React.ChangeEventHandler<HTMLInputElement>;\n  handleChangeEvent: React.ChangeEventHandler<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>;\n  handleValueChange: (newValue: T) => void;\n\n  error: IComputedValue<string | undefined>;\n  formIsSubmitting: IComputedValue<boolean>;\n  isTouched: IComputedValue<boolean | undefined>;\n  validationState: IComputedValue<'error' | 'warning' | 'success' | undefined>;\n  value: IComputedValue<T>;\n}\n\nexport class FormDomain<T extends Record<string, any>> {\n  constructor(props: FormDomainProps<T>) {\n    this.schema = props.validationSchema;\n    this.initialValues = toJS(props.initialValues);\n    this.userHandleSubmit = props.onSubmit;\n\n    // using an observable object instead of observable map because:\n    // - observable.map value types are weak\n    // - yup expects an object when validating, so we'd be converting back and forth from map to object\n    this.fieldValues = Object.assign({}, this.initialValues);\n\n    // NOTE(meyer) the validate function call will never throw (exceptions are all handled internally)\n    // tslint:disable-next-line: no-floating-promises\n    this.validate();\n  }\n\n  public readonly errorMap = observable.map<keyof T, string>(undefined, {\n    name: 'FormDomain.errorMap',\n  });\n  public readonly touchedFields = observable.map<keyof T, boolean>(undefined, {\n    name: 'FormDomain.touchedFields',\n  });\n  public readonly userHandleSubmit: SubmitHandler<T>;\n\n  private validationCounter = 0;\n  private readonly initialValues: T;\n  private readonly schema: ObjectSchema<T>;\n  private readonly fieldContextObjs: Record<string, FieldContextObj<any>> = {};\n\n  public fieldValues: T;\n  public formIsSubmitting = false;\n  public formIsValid: boolean | null = null;\n  public formIsValidating = false;\n  public formStatus: FormStatus | null = null;\n\n  public get formIsDirty() {\n    return Object.is(this.initialValues, this.fieldValues);\n  }\n\n  public getFieldContextObject = <K extends any = any>(name: Extract<keyof T, string>): FieldContextObj<K> => {\n    if (!this.fieldContextObjs[name]) {\n      const handleValueChange = (newValue: any) => this.setField(name, newValue);\n\n      const handleChangeEvent: React.ChangeEventHandler<\n        HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n      > = e => this.setField(name, e.target.value as any);\n\n      const handleCheckboxChange: React.ChangeEventHandler<HTMLInputElement> = e =>\n        this.setField(name, e.target.checked as any);\n\n      const handleFocus = () => this.setTouched(name);\n\n      const handleBlur = () => this.setTouched(name);\n\n      this.fieldContextObjs[name] = {\n        name,\n\n        handleFocus,\n        handleBlur,\n        handleCheckboxChange,\n        handleChangeEvent,\n        handleValueChange,\n\n        // we use computed values here so that the individual values can be observed\n        error: computed(() => (this.touchedFields.has(name) ? this.errorMap.get(name) : undefined), { name: 'error' }),\n        formIsSubmitting: computed(() => this.formIsSubmitting),\n        isTouched: computed(() => this.touchedFields.has(name), {\n          name: 'isTouched',\n        }),\n        validationState: computed<ValidationState | undefined>(\n          () => {\n            const isTouched = this.touchedFields.has(name);\n            const hasError = this.errorMap.has(name);\n\n            if (!isTouched) {\n              return hasError ? 'warning' : undefined;\n            }\n\n            return hasError ? 'error' : 'success';\n          },\n          { name: 'validationState' }\n        ),\n        value: computed(() => this.fieldValues[name], { name: 'value' }),\n      };\n    }\n\n    return this.fieldContextObjs[name];\n  };\n\n  public handleSubmit: React.FormEventHandler<HTMLFormElement> = e => {\n    e.preventDefault();\n\n    if (this.formIsSubmitting) {\n      console.error('Form is already submitting');\n      return;\n    }\n    this.formIsSubmitting = true;\n\n    const handleError = (err: any): FormStatus => {\n      return {\n        appearance: 'danger',\n        message: err + '',\n      };\n    };\n\n    this.userHandleSubmit(toJS(this.fieldValues))\n      // handle errors\n      .then(undefined, handleError)\n      .catch(handleError)\n      // set status\n      .then(formStatus => {\n        runInAction('handleSubmit async', () => {\n          if (formStatus && formStatus.hideAfter) {\n            const { hideAfter } = formStatus;\n            this.formStatus = formStatus;\n            setTimeout(() => {\n              runInAction('handleSubmit hideAfter', () => {\n                this.formStatus = null;\n                this.formIsSubmitting = false;\n              });\n            }, hideAfter);\n          } else {\n            this.formStatus = formStatus || null;\n            this.formIsSubmitting = false;\n          }\n        });\n      });\n  };\n\n  public handleReset = (): void => {\n    this.fieldValues = Object.assign({}, this.initialValues);\n  };\n\n  public validate = (): Promise<boolean | null> => {\n    this.formIsValidating = true;\n    this.formIsValid = null;\n    this.formStatus = null;\n\n    const counter = ++this.validationCounter;\n\n    const handleValidationError = (err: unknown): boolean | null => {\n      if (this.validationCounter !== counter) {\n        return null;\n      }\n\n      console.log(err);\n\n      const errorObj: Record<string, string> = {};\n      let formStatus: FormStatus | null = null;\n\n      if (isValidationError(err)) {\n        if (err.inner.length === 0) {\n          errorObj[err.path] = err.message;\n        } else {\n          for (const innerErr of err.inner) {\n            if (innerErr.path === '') {\n              formStatus = {\n                appearance: 'danger',\n                message: innerErr.message,\n              };\n            } else {\n              errorObj[innerErr.path] = innerErr.message;\n            }\n          }\n        }\n      } else {\n        // treat non-ValidationErrors as general (not field-specific) errors\n        formStatus = {\n          appearance: 'danger',\n          message: err + '',\n        };\n      }\n\n      runInAction('validate failure', () => {\n        this.formIsValidating = false;\n        this.formIsValid = false;\n        this.formStatus = formStatus;\n        this.errorMap.replace(errorObj);\n      });\n\n      return false;\n    };\n\n    return this.schema\n      .validate(this.fieldValues, {\n        // This option causes validation to stop upon first error. It defaults to true.\n        //   We want validation to run for every field, so we disable it.\n        abortEarly: false,\n      })\n      .then(() => {\n        // this is gross but it's easier than using object equality\n        if (this.validationCounter !== counter) {\n          return null;\n        }\n\n        runInAction('validate success', () => {\n          this.formIsValid = true;\n          this.formIsValidating = false;\n        });\n\n        return true;\n      }, handleValidationError)\n      .catch(handleValidationError);\n  };\n\n  public setField = <K extends keyof T>(field: K, value: T[K]): void => {\n    // NOTE(meyer) the validate function call will never throw (exceptions are all handled internally)\n    // tslint:disable-next-line: no-floating-promises\n    this.errorMap.delete(field);\n    this.validate();\n    this.fieldValues[field] = value;\n  };\n\n  public setTouched = <K extends keyof T>(field: K, touched: boolean = true): void => {\n    if (this.touchedFields.get(field) !== touched) {\n      this.touchedFields.set(field, touched);\n    }\n    if (touched) {\n      this.errorMap.delete(field);\n    }\n    // NOTE(meyer) the validate function call will never throw (exceptions are all handled internally)\n    // tslint:disable-next-line: no-floating-promises\n    this.validate();\n  };\n}\n\n// using decorate here because decorator output is hella nasty\ndecorate(FormDomain, {\n  formIsDirty: computed,\n\n  handleSubmit: action,\n  handleReset: action,\n  validate: action,\n  setField: action,\n  setTouched: action,\n\n  fieldValues: observable,\n  formIsSubmitting: observable,\n  formIsValid: observable,\n  formIsValidating: observable,\n  formStatus: observable,\n});\n","import { createElement, PropsWithChildren, ReactElement, useRef, useContext, createContext } from 'react';\nimport { FormDomain, FormDomainProps } from './FormDomain';\n\nexport const FormContext = createContext<FormDomain<any>>(undefined as any);\n\nexport const useFormContext = <T extends object>() => useContext<FormDomain<T>>(FormContext);\n\n// This provider component abstracts away the FormDomain creation logic. We use a custom type def here\n//   instead of React.FC because the `initialProps` type needs to be inferrable.\nexport const FormContextProvider = <T extends object>(\n  props: PropsWithChildren<FormDomainProps<T>>\n): ReactElement | null => {\n  const formDomainRef = useRef<FormDomain<T>>();\n\n  if (!formDomainRef.current) {\n    formDomainRef.current = new FormDomain(props);\n  }\n\n  return createElement(FormContext.Provider, { value: formDomainRef.current }, props.children);\n};\n","import { createContext, useContext } from 'react';\nimport { FieldContextObj } from './FormDomain';\nimport { FormContext } from './FormContext';\n\nexport const FieldNameContext = createContext<string>(undefined as any);\n\nexport const useFieldContext = <T extends any = any>(fieldName?: string): FieldContextObj<T> => {\n  const formContext = useContext(FormContext);\n  const ctxFieldName = useContext(FieldNameContext);\n\n  // Allow the user to override the fieldName (hmmmmmmmm...)\n  return formContext.getFieldContextObject(fieldName || ctxFieldName);\n};\n","import { useObserver } from 'mobx-react-lite';\nimport { ReactElement, ReactNode, useMemo } from 'react';\nimport { computed } from 'mobx';\nimport { useFormContext } from './FormContext';\n\ninterface BaseFormIfProps<T extends object> {\n  /**\n   * Function that takes the current observable form values and returns a boolean\n   * indicating whether or not the component's children should be rendered.\n   */\n  predicate: (values: T) => boolean;\n}\n\ninterface FormIfFunctionProps<T extends object> extends BaseFormIfProps<T> {\n  children: (predicateIsTrue: boolean) => ReactNode;\n}\n\ninterface FormIfChildProps<T extends object> extends BaseFormIfProps<T> {\n  children?: ReactNode;\n}\n\ntype FormIfProps<T extends object> = FormIfFunctionProps<T> | FormIfChildProps<T>;\n\n/**\n * This component runs the provided `predicate` function and renders the `children` only if the return value of the predicate function is `true`.\n *\n * If you would rather have access to the predicate value (to, say, render a different value for `true` and `false` cases),\n *   a child function can be passed that receives the predicate value and returns either a `ReactElement` or `null`.\n */\nexport const FormIf = <T extends object>({ predicate, children }: FormIfProps<T>): ReactElement | null => {\n  const formContext = useFormContext<T>();\n  // since fieldValues is an observable object, we can utilise a computed to prevent unnecessary re-renders\n  const computedPredicate = useMemo(() => computed(() => predicate(formContext.fieldValues)), [predicate]);\n\n  return useObserver(() => {\n    const predicateIsTrue = computedPredicate.get();\n    if (typeof children === 'function') {\n      return children(predicateIsTrue);\n    }\n    return predicateIsTrue ? children : null;\n  });\n};\n"],"names":["isValidationError","err","name","FormDomain","constructor","props","observable","map","undefined","fieldContextObjs","handleValueChange","newValue","setField","handleChangeEvent","e","target","value","handleCheckboxChange","checked","handleFocus","setTouched","handleBlur","error","computed","touchedFields","has","errorMap","get","formIsSubmitting","isTouched","validationState","hasError","fieldValues","preventDefault","console","handleError","appearance","message","userHandleSubmit","toJS","then","catch","formStatus","runInAction","hideAfter","setTimeout","Object","assign","initialValues","formIsValidating","formIsValid","counter","validationCounter","handleValidationError","log","errorObj","inner","length","path","innerErr","replace","schema","validate","abortEarly","field","delete","touched","set","validationSchema","onSubmit","formIsDirty","is","decorate","handleSubmit","action","handleReset","FormContext","createContext","useFormContext","useContext","FormContextProvider","formDomainRef","useRef","current","createElement","Provider","children","FieldNameContext","useFieldContext","fieldName","formContext","ctxFieldName","getFieldContextObject","FormIf","predicate","computedPredicate","useMemo","useObserver","predicateIsTrue"],"mappings":"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"}