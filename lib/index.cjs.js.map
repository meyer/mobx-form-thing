{"version":3,"file":"index.cjs.js","sources":["../src/utils.ts","../src/validationHandlers.ts","../src/getFormContext.ts","../src/FormContext.ts","../src/FieldContext.ts","../src/FormIf.ts"],"sourcesContent":["import { ValidationError } from 'yup';\n\nexport const isValidationError = (err: any): err is ValidationError => {\n  if (!err || typeof err !== 'object') {\n    return false;\n  }\n  return err.name === 'ValidationError';\n};\n","import { isValidationError } from './utils';\nimport { ReactChild } from 'react';\nimport { observable, action } from 'mobx';\nimport { ObjectSchema } from 'yup';\n\nexport interface FormStatus {\n  appearance?: 'info' | 'warning' | 'danger' | 'success';\n  message: ReactChild;\n  hideAfter?: number;\n}\n\nexport interface ValidationResult<T extends object> {\n  isValid: boolean | null;\n  status: FormStatus | null;\n  errors: Partial<Record<keyof T, string>> | null;\n}\n\ninterface PendingPromise<T> {\n  state: 'pending';\n  value: T;\n}\n\ninterface FulfilledPromise<T> {\n  state: 'fulfilled';\n  value: T;\n}\n\ninterface RejectedPromise<T> {\n  state: 'rejected';\n  value: T;\n}\n\nexport type PromiseBasedObservable<T> = PendingPromise<T> | FulfilledPromise<T> | RejectedPromise<T>;\n\nexport const getValidationResultForValues = <T extends object>(\n  schema: ObjectSchema<T>,\n  values: T\n): PromiseBasedObservable<ValidationResult<T>> => {\n  const obj = observable.object<PromiseBasedObservable<ValidationResult<T>>>(\n    {\n      value: {\n        errors: null,\n        isValid: null,\n        status: null,\n      },\n      state: 'pending',\n    },\n    undefined,\n    { deep: false }\n  );\n\n  schema\n    .validate(values, {\n      // This option causes validation to stop upon first error. It defaults to true.\n      //   We want validation to run for every field, so we disable it.\n      abortEarly: false,\n    })\n    .then(handleValidationSuccess, handleValidationError)\n    .catch(handleValidationError)\n    .then(\n      action((value: any) => {\n        obj.value = value;\n        obj.state = 'fulfilled';\n      }),\n      action(reason => {\n        console.error(reason);\n        obj.value = {\n          errors: null,\n          isValid: false,\n          status: {\n            appearance: 'danger',\n            message: reason + '',\n          },\n        };\n        obj.state = 'rejected';\n      })\n    );\n\n  return obj;\n};\n\nconst handleValidationSuccess = <T extends object>(): ValidationResult<T> => ({\n  isValid: true,\n  status: null,\n  errors: null,\n});\n\nconst handleValidationError = <T extends object>(err: unknown): ValidationResult<T> => {\n  const errorObj: Partial<Record<keyof T | string, string>> = {};\n  let formStatus: FormStatus | null = null;\n\n  if (isValidationError(err)) {\n    if (err.inner.length === 0) {\n      errorObj[err.path] = err.message;\n    } else {\n      for (const innerErr of err.inner) {\n        if (innerErr.path === '') {\n          formStatus = {\n            appearance: 'danger',\n            message: innerErr.message,\n          };\n        } else {\n          errorObj[innerErr.path] = innerErr.message;\n        }\n      }\n    }\n  } else {\n    // treat non-ValidationErrors as general (not field-specific) errors\n    formStatus = {\n      appearance: 'danger',\n      message: err + '',\n    };\n  }\n\n  return {\n    isValid: false,\n    errors: errorObj,\n    status: formStatus,\n  };\n};\n","import { computed, observable, toJS, IObservableObject, action } from 'mobx';\nimport React from 'react';\nimport { ObjectSchema } from 'yup';\nimport {\n  FormStatus,\n  ValidationResult,\n  PromiseBasedObservable,\n  getValidationResultForValues,\n} from './validationHandlers';\n\ntype ValidationState = 'warning' | 'success' | 'error';\n\n// These field props are usually handled by methods and values on the field context.\ntype OmittedProps = 'validationState' | 'onChange' | 'onBlur' | 'name' | 'value' | 'defaultValue';\n\n/** Exclude common handled field props from an interface */\nexport type OmitFieldProps<T> = Pick<T, Exclude<keyof T, OmittedProps>>;\n\n/** Handler passed as the `onSubmit` prop */\nexport type FormSubmitHandler<T extends object> = (values: T) => Promise<FormStatus | undefined>;\n\nexport interface FormContextProps<T extends object> {\n  initialValues: T;\n  validationSchema: ObjectSchema<T>;\n  onSubmit: FormSubmitHandler<T>;\n}\n\nexport interface FieldContextObj<T extends any> {\n  name: string;\n\n  handleFocus: () => void;\n  handleBlur: () => void;\n  handleCheckboxChange: React.ChangeEventHandler<HTMLInputElement>;\n  handleChangeEvent: React.ChangeEventHandler<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>;\n  handleValueChange: (newValue: T) => void;\n\n  error: string | undefined;\n  formIsSubmitting: boolean;\n  isTouched: boolean | undefined;\n  validationState: 'error' | 'warning' | 'success' | undefined;\n  value: T;\n}\n\ninterface FormState<T extends object> {\n  errors: Partial<Record<keyof T, string | undefined>> | null;\n  formStatus: FormStatus | null;\n  isDirty: boolean;\n  isSubmitting: boolean;\n  isValid: boolean | null;\n  isValidating: boolean;\n  setField<K extends keyof T>(field: K, value: T[K]): void;\n  setTouched<K extends keyof T>(field: K, touched?: boolean): void;\n  touchedFields: Partial<Record<keyof T, boolean>>;\n  handleReset: () => void;\n  handleSubmit: React.FormEventHandler<HTMLFormElement>;\n  validationResult: PromiseBasedObservable<ValidationResult<T>>;\n  values: T;\n}\n\nexport interface FormContextObj<T extends object> {\n  formState: FormState<T> & IObservableObject;\n  getFieldContextObject: <K extends any = any>(name: Extract<keyof T, string>) => FieldContextObj<K>;\n}\n\nexport function getFormContext<T extends Record<string, any>>(props: FormContextProps<T>): FormContextObj<T> {\n  const schema: ObjectSchema<T> = props.validationSchema;\n  const initialValues: T = toJS(props.initialValues);\n  const userHandleSubmit: FormSubmitHandler<T> = props.onSubmit;\n\n  const fieldContextObjs: Record<string, FieldContextObj<any>> = {};\n\n  const formState = observable.object<FormState<T>>(\n    {\n      values: Object.assign({}, initialValues),\n      isSubmitting: false,\n      touchedFields: {},\n\n      get validationResult(): PromiseBasedObservable<ValidationResult<T>> {\n        return getValidationResultForValues(schema, this.values);\n      },\n\n      get isValid(): null | boolean {\n        return this.validationResult.value.isValid;\n      },\n\n      get isValidating(): boolean {\n        return this.validationResult.state === 'pending';\n      },\n\n      get formStatus(): FormStatus | null {\n        return this.validationResult.value.status;\n      },\n\n      get errors(): Partial<Record<keyof T, string>> | null {\n        return this.validationResult.value.errors;\n      },\n\n      get isDirty() {\n        return Object.is(initialValues, this.values);\n      },\n\n      setField<K extends keyof T>(field: K, value: T[K]): void {\n        if (this.errors) {\n          this.errors[field] = undefined;\n        }\n        this.values[field] = value;\n      },\n\n      setTouched<K extends keyof T>(field: K, touched: boolean = true): void {\n        if (this.touchedFields[field] !== touched) {\n          this.touchedFields[field] = touched;\n        }\n        if (touched && this.errors) {\n          this.errors[field] = undefined;\n        }\n      },\n\n      handleReset(): void {\n        this.values = Object.assign({}, initialValues);\n      },\n\n      handleSubmit(e) {\n        e.preventDefault();\n\n        if (this.isSubmitting) {\n          console.error('Form is already submitting');\n          return;\n        }\n\n        this.isSubmitting = true;\n\n        const handleError = (err: any): FormStatus => ({\n          appearance: 'danger',\n          message: err + '',\n        });\n\n        userHandleSubmit(toJS(this.values))\n          // convert error to FormStatus\n          .then(undefined, handleError)\n          .catch(handleError)\n          // set status\n          .then(\n            action('handleSubmit async', (formStatus: FormStatus | undefined) => {\n              this.formStatus = formStatus || null;\n              const hideAfter = formStatus && formStatus.hideAfter;\n              if (hideAfter) {\n                setTimeout(\n                  action('handleSubmit hideAfter', () => {\n                    this.formStatus = null;\n                    this.isSubmitting = false;\n                  }),\n                  hideAfter\n                );\n              } else {\n                this.isSubmitting = false;\n              }\n            })\n          );\n      },\n    },\n    {\n      validationResult: computed,\n      isValid: computed,\n      isValidating: computed,\n      formStatus: computed,\n      errors: computed,\n      isDirty: computed,\n\n      setField: action,\n      setTouched: action,\n      handleReset: action,\n      handleSubmit: action,\n    }\n  );\n\n  const getFieldContextObject = <K extends any = any>(name: Extract<keyof T, string>): FieldContextObj<K> => {\n    if (!fieldContextObjs[name]) {\n      const handleValueChange = (newValue: any) => formState.setField(name, newValue);\n\n      const handleChangeEvent: React.ChangeEventHandler<\n        HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n      > = e => formState.setField(name, e.target.value as any);\n\n      const handleCheckboxChange: React.ChangeEventHandler<HTMLInputElement> = e =>\n        formState.setField(name, e.target.checked as any);\n\n      const handleFocus = () => formState.setTouched(name);\n\n      const handleBlur = () => formState.setTouched(name);\n\n      fieldContextObjs[name] = observable.object(\n        {\n          name,\n\n          handleFocus,\n          handleBlur,\n          handleCheckboxChange,\n          handleChangeEvent,\n          handleValueChange,\n\n          get error(): string | undefined {\n            // const isTouched = ret.touchedFields[name];\n            return (formState.errors && formState.errors[name]) || undefined;\n          },\n\n          get formIsSubmitting(): boolean {\n            return formState.isSubmitting;\n          },\n\n          get isTouched(): boolean {\n            return !!formState.touchedFields[name];\n          },\n\n          get validationState(): ValidationState | undefined {\n            if (!this.isTouched) {\n              return this.error ? 'warning' : undefined;\n            }\n\n            return this.error ? 'error' : 'success';\n          },\n\n          get value(): T {\n            return formState.values[name];\n          },\n        },\n        {\n          error: computed,\n          formIsSubmitting: computed,\n          isTouched: computed,\n          validationState: computed,\n          value: computed,\n        },\n        {\n          name: `fieldContext:${name}`,\n          deep: false,\n        }\n      );\n    }\n\n    return fieldContextObjs[name];\n  };\n\n  return { formState, getFieldContextObject };\n}\n","import { createElement, PropsWithChildren, ReactElement, useRef, useContext, createContext } from 'react';\nimport { getFormContext, FormContextObj, FormContextProps } from './getFormContext';\n\nexport const FormContext = createContext<FormContextObj<any>>(undefined as any);\n\nexport const useFormContext = <T extends object>() => useContext<FormContextObj<T>>(FormContext);\n\n// This provider component abstracts away the FormDomain creation logic. We use a custom type def here\n//   instead of React.FC because the `initialProps` type needs to be inferrable.\nexport const FormContextProvider = <T extends object>(\n  props: PropsWithChildren<FormContextProps<T>>\n): ReactElement | null => {\n  const formDomainRef = useRef<FormContextObj<T>>();\n\n  if (!formDomainRef.current) {\n    formDomainRef.current = getFormContext(props);\n  }\n\n  return createElement(FormContext.Provider, { value: formDomainRef.current }, props.children);\n};\n","import { createContext, useContext } from 'react';\nimport { FormContext } from './FormContext';\nimport { FieldContextObj } from './getFormContext';\n\nexport const FieldNameContext = createContext<string>(undefined as any);\n\nexport const useFieldContext = <T extends any = any>(fieldName?: string): FieldContextObj<T> => {\n  const { getFieldContextObject } = useContext(FormContext);\n  const ctxFieldName = useContext(FieldNameContext);\n\n  // Allow the user to override the fieldName (hmmmmmmmm...)\n  return getFieldContextObject(fieldName || ctxFieldName);\n};\n","import { useObserver } from 'mobx-react-lite';\nimport { ReactElement, ReactNode, useMemo } from 'react';\nimport { computed } from 'mobx';\nimport { useFormContext } from './FormContext';\n\ninterface BaseFormIfProps<T extends object> {\n  /**\n   * Function that takes the current observable form values and returns a boolean\n   * indicating whether or not the component's children should be rendered.\n   */\n  predicate: (values: T) => boolean;\n}\n\ninterface FormIfFunctionProps<T extends object> extends BaseFormIfProps<T> {\n  children: (predicateIsTrue: boolean) => ReactNode;\n}\n\ninterface FormIfChildProps<T extends object> extends BaseFormIfProps<T> {\n  children?: ReactNode;\n}\n\ntype FormIfProps<T extends object> = FormIfFunctionProps<T> | FormIfChildProps<T>;\n\n/**\n * This component runs the provided `predicate` function and renders the `children` only if the return value of the predicate function is `true`.\n *\n * If you would rather have access to the predicate value (to, say, render a different value for `true` and `false` cases),\n *   a child function can be passed that receives the predicate value and returns either a `ReactElement` or `null`.\n */\nexport const FormIf = <T extends object>({ predicate, children }: FormIfProps<T>): ReactElement | null => {\n  const { formState } = useFormContext<T>();\n  // since fieldValues is an observable object, we can utilise a computed to prevent unnecessary re-renders\n  const computedPredicate = useMemo(() => computed(() => predicate(formState.values)), [predicate]);\n\n  return useObserver(() => {\n    const predicateIsTrue = computedPredicate.get();\n    if (typeof children === 'function') {\n      return children(predicateIsTrue);\n    }\n    return predicateIsTrue ? children : null;\n  });\n};\n"],"names":["isValidationError","err","name","getValidationResultForValues","schema","values","obj","observable","object","value","errors","isValid","status","state","undefined","deep","validate","abortEarly","then","handleValidationSuccess","handleValidationError","catch","action","reason","console","error","appearance","message","errorObj","formStatus","inner","length","path","innerErr","getFormContext","props","validationSchema","initialValues","toJS","userHandleSubmit","onSubmit","fieldContextObjs","formState","Object","assign","isSubmitting","touchedFields","validationResult","isValidating","isDirty","is","setField","field","setTouched","touched","handleReset","handleSubmit","e","preventDefault","handleError","hideAfter","setTimeout","computed","getFieldContextObject","handleValueChange","newValue","handleChangeEvent","target","handleCheckboxChange","checked","handleFocus","handleBlur","formIsSubmitting","isTouched","validationState","FormContext","createContext","useFormContext","useContext","FormContextProvider","formDomainRef","useRef","current","createElement","Provider","children","FieldNameContext","useFieldContext","fieldName","ctxFieldName","FormIf","predicate","computedPredicate","useMemo","useObserver","predicateIsTrue","get"],"mappings":"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"}